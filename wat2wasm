#!/usr/bin/env node

import {readFileSync, writeFileSync, watchFile, existsSync, unlinkSync } from "fs"
import {execSync} from "child_process"

const [ node, wat2wasm, inputFilePath, ...compileOptions ] = process.argv;

const tbl_extern = [ null ];
const data_text = [];
let data_text_offset = 0;
// const encode = TextEncoder.prototype.encode.bind(new TextEncoder);
const encode = str => new Uint8Array(Float32Array.from(str.split("").map(c => c.charCodeAt())).buffer);


String.prototype.frameAt         = function ( index ) {

    let lastIndex   = this.indexOf(")", index) + 1;
    let frame       = this.substring(index, lastIndex);
    let maxIndex    = this.length;

    if (frame.startsWith("(")) {
        while (frame.split("(").length !== frame.split(")").length) {
            lastIndex = this.indexOf(")", lastIndex )+1;
            frame = this.substring( index, lastIndex );
    
            if (lastIndex >= maxIndex) {
                process.exit(console.log("frame error:", frame));
                break;
            }
        }
    } else {
        process.exit(console.log("frame not started with (", frame));
    }

    return frame;
};

String.prototype.matchFrame         = function ( regExp ) {

    let match;
    
    match = this.match(regExp);

    if (match) {

        let frame       = match[0];
        let lastIndex   = match.index;
        let maxIndex    = match.input.length;
    
        if (frame.startsWith("(")) {
            while (frame.split("(").length !== frame.split(")").length) {
                lastIndex = this.indexOf(")", lastIndex)+1;
                frame = this.substring( match.index, lastIndex );
        
                if (lastIndex >= maxIndex) {
                    process.exit(console.log("frame error:", match[0]));
                    break;
                }
            }
        } else {
            process.exit(console.log("frame not started with (", match[0]));
        }
    
        match.frame = frame;
        match.end = match.index + frame.length;
    }

    return match;
};

String.prototype.replaceFrame       = function ( match, replaceWith = "" ) {

    if (match.index === match.end) {
        process.exit(console.log("frame error", match));
    }

    return this
        .substring( 0, match.index )
        .concat( replaceWith )
        .concat( this.substring( match.end ) )
    ;
};

String.prototype.removeFrame        = function ( match ) {
    return this.replaceFrame( match, "" );
};

String.prototype.findQuotedText     = function () {

    let opener = this.match(/\"|\'|\`/);
    let qtext  = "";

    if (opener) {
        
        let begin       = opener.index;
        let quote       = opener[0];
        let maxIndex    = this.length;
        let nextIndex   = this.indexOf(quote, begin+1);

        if (nextIndex !== -1) {

            while ( this.charAt(nextIndex-1) === "\\" ) {
                nextIndex = this.indexOf(quote, nextIndex+1);
                if (nextIndex >= maxIndex) {
                    break;
                }
            }
        
            qtext = this.substring(begin+1, nextIndex);
        }
    
    }

    return qtext;
};

const indexOfOutputPathCompileOptionsParameter = compileOptions.findIndex(opt => opt === "-o") + 1;
const outputFilePath = 
    indexOfOutputPathCompileOptionsParameter && 
    compileOptions[indexOfOutputPathCompileOptionsParameter] || 
    inputFilePath.replace(".wat", ".wasm")
;

const modifiedContentInputFilePath  = inputFilePath + "2wasm.wat";
const enableThreadsCompileOptions   = compileOptions.find(o => o.match(/enable-threads/)) || "";
const debugNamesCompileOptions      = compileOptions.find(o => o.match(/debug-names/)) || "";
const multiMemoryCompileOptions     = compileOptions.find(o => o.match(/multi-memory/)) || "";
const noUnlinkCompileOptions        = compileOptions.find(o => o.match(/no-unlink/)) || "";

const include   = content => {
    let match;
    
    while (match = content.matchFrame(/\(include\s+/)) {
        const includePath = match.frame.findQuotedText();

        if (existsSync(includePath)){
            content = content.replaceFrame( match, 
                readFileSync(includePath)
                    .toString()
                    .trim() 
            );
        }
        else {
            content = content.removeFrame( match );
        }
    }   
    
    return content;
}

const consoles   = content => {
    return content.replaceAll(/\((log|warn|error)\</g, "(call $self.console.$1<");
}

const start     = content => {
    let match;
    
    if (match = content.matchFrame(/\(start\s+\$(.[^\s|\)]*)/)) {
        const funcName = match[1];
        if (!content.match(new RegExp(`\\\(func\\s+\\\$${funcName}`))) {
            content = content
                .replace( match[0], `(start $${funcName}) (func $${funcName} `);
        }
    }   
    
    return content;
}

const inlinefuncs     = content => {
    let match;
    
    let lastfuncIndex = content.lastIndexOf("(func ", content.length);
    let lastfuncFrame;
    
    
    while (lastfuncIndex > 0) {
        lastfuncFrame = content.frameAt(lastfuncIndex);
        if (lastfuncFrame.indexOf("(func", 1) !== -1) {
        
            let nlb = lastfuncFrame.frameAt(lastfuncFrame.lastIndexOf("(func"));
            let fname = nlb.split("$").at(1).split(/[\s|\(|\)]/).at(0);
            content = content.substring(0, lastfuncIndex).concat(nlb).concat(content.substring(lastfuncIndex).replace(nlb, `(ref.func $${fname})`))

            return inlinefuncs(content);

        }
        lastfuncIndex = content.lastIndexOf("(func ", lastfuncIndex-1);
    }

    
    return content;
}

const textref   = content => {

    let match;
    
    while (match = content.matchFrame(/\(text\s+/)) {
        const text = match.frame.findQuotedText();
        let index = tbl_extern.indexOf(text);

        if (index === -1) {
            index += tbl_extern.push( text );
            const data = { text, index, buffer: encode(text) };

            data.data_text_offset   = data_text_offset;
            data.data_text_length   = data.buffer.byteLength;
            data.data_text_end      = data_text_offset += data.data_text_length;

            data_text.push(data);
        }

        const call = `(table.get $extern (i32.const ${index}))`;

        content = content.replaceFrame( match, call );
    }   
    
    return content;
};

const appendExternTable = content => {    
    return content
        .substring(0, content.lastIndexOf(")"))
        .concat(`
    (table $extern ${tbl_extern.length} ${tbl_extern.length} externref)\n`)
        .concat(
            content.substring(content.lastIndexOf(")"))
        )
    ;
}

const appendTextFunc = content => {    

    return content;
}

const insertStartFunc = content => {
    if (content.match(/\(start\s+\$(.[^\s|\)]*)/)) {
        return content;
    }
        
    return content
        .substring(0, content.lastIndexOf(")"))
        .concat(`
        (start $wat2wasm/start) 
        (func $wat2wasm/start 
            
        )\n`)
        .concat(
            content.substring(content.lastIndexOf(")"))
        )
    ;
}

const callOnStart = (content, call) => {
    content = insertStartFunc(content);

    const startMatch = content.match(/\(start\s+\$(.[^\s|\)]*)/);
    const startFuncName = startMatch.at(1);
    const startFuncMatch = content.match(new RegExp(`\\\(func\\s+\\\$${startFuncName}`));
    const startFuncContentBegin = startFuncMatch.index + startFuncMatch[0].length;

    return content.substring(
        0, startFuncContentBegin
    ).concat( `
        ${call}    
    ` ).concat(
        content.substring( startFuncContentBegin )
    )
};


const appendTextData = content => {    
    const hex = data_text.flatMap(d => Array.from(d.buffer)).map(c => c.toString(16).padStart(2,0)).join("\\");

    content = callOnStart( content, `
        (memory.fill (i32.const 0) (i32.const 0) (i32.const ${data_text_offset}))
        (data.drop $wat2wasm/text)`);

    content = callOnStart(content, data_text.map(dt => 
        `(table.set $extern (i32.const ${dt.index}) (call $wat2wasm/text (i32.const ${dt.data_text_offset}) (i32.const ${dt.data_text_length})))`).join("\n\t\t")
    );

    content = callOnStart( addPrimaryMemory(content), `
        (memory.init 0 $wat2wasm/text (i32.const 0) (i32.const 0) (i32.const ${data_text_offset}))`);

    return appendTextFunc( content )
        .substring(0, content.lastIndexOf(")"))
        .concat(`
    (func $wat2wasm/text 
        (param $offset i32)
        (param $length i32)
        (result externref)
        (local $array externref)

        (if (i32.eqz (local.get $length))
            (then (return (ref.null extern)))
        )

        (local.set $array 
            (call $wat2wasm/Array<>ref)
        )

        (loop $length--
            (local.set $length
                (i32.sub (local.get $length) (i32.const 4))
            )
                
            (call $wat2wasm/Reflect.set<ref.i32x2>
                (local.get $array)
                (i32.div_u (local.get $length) (i32.const 4))
                (i32.trunc_f32_u	
                    (f32.load 
                        (i32.add 
                            (local.get $offset)
                            (local.get $length)
                        )
                    )
                )
            )

            (br_if $length-- (local.get $length))
        )

        (call $wat2wasm/Reflect.apply<refx3>ref
            (global.get $wat2wasm/String.fromCharCode)
            (ref.null extern)
            (local.get $array)
        )
    )

    (data $wat2wasm/text "\\${hex}")\n`)
        .concat(
            content.substring(content.lastIndexOf(")"))
        )
    ;
}

const addImports = content => {
    let firstImportIndex = content.indexOf("(import ");
    if (firstImportIndex === -1) {
        firstImportIndex = content.indexOf("(module ") + 8;
    }

    return content.substring(
        0, firstImportIndex
    ).concat(`
    ;;BEGIN_OF_IMPORTS
    (import "self" "Array"              (func $wat2wasm/Array<>ref (param) (result externref)))
    (import "Reflect" "set"             (func $wat2wasm/Reflect.set<ref.i32x2> (param externref i32 i32) (result)))
    (import "Reflect" "getOwnPropertyDescriptor" (func $wat2wasm/Reflect.getOwnPropertyDescriptor<refx2>ref (param externref externref) (result externref)))
    (import "Reflect" "get"             (func $wat2wasm/Reflect.get<refx2>ref (param externref externref) (result externref)))
    (import "Reflect" "get"             (func $wat2wasm/Reflect.get<refx2>i32 (param externref externref) (result i32)))
    (import "Reflect" "get"             (func $wat2wasm/Reflect.get<refx2>f32 (param externref externref) (result f32)))
    (import "Reflect" "get"             (func $wat2wasm/Reflect.get<refx2>i64 (param externref externref) (result i64)))
    (import "Reflect" "get"             (func $wat2wasm/Reflect.get<refx2>f64 (param externref externref) (result f64)))
    (import "Reflect" "apply"           (func $wat2wasm/Reflect.apply<refx3>ref (param externref externref externref) (result externref)))
    (import "self" "self"               (global $wat2wasm/self externref))
    (import "String" "fromCharCode"     (global $wat2wasm/String.fromCharCode externref))
    ;;END_OF_IMPORTS
    `).concat(
        content.substring(firstImportIndex)
    )
};

const addPrimaryMemory = content => {
    let firstMemoryIndex = content.indexOf("(memory ");
    if (firstMemoryIndex !== -1) {
        return content;
    }

    firstMemoryIndex = content.lastIndexOf(")");

    const pages = Math.ceil(data_text_offset/65535);

    return content.substring(
        0, firstMemoryIndex
    ).concat(`
    (memory $wat2wasm/text ${pages} ${pages})
    `).concat(
        content.substring(firstMemoryIndex)
    )
};

const selfref           = content => {

    let match;
    let setters = ``;
    
    while (match = content.matchFrame(/\(global\s+\$(self\.[a-zA-Z0-9._:/]+)\s+(i32|f32|i64|f64|externref)\s?\)/)) {
        const kind = match[2];
        const kindshort = kind.replace("externref", "ref");
        const kinddefiner = `(mut ${kind})`;
        const initial = kind === "externref" && "ref.null extern" || `(${kind}.const 0)`;
        
        const global_name = match[1];
        const descriptor_property = global_name.split("/").at(1) || "value"; 
        const object_path = global_name.replace(/[:]+/,".prototype.").replaceAll("self.", "").split("/").at(0);
        const path_parts = object_path.split(".");

        const root_object = path_parts[0];
        const last_object = path_parts[path_parts.length-1];
        let path_index = path_parts.length;
        let path_walk = `(global.get $wat2wasm/self)`;

        let walk_step = 0;
        while (--path_index) {
            const step_part = path_parts[walk_step++];

                path_walk = textref(`(call $wat2wasm/Reflect.get<refx2>ref 
                    ${path_walk} 
                    (text "${step_part}") 
                )`).split("\n").join( "\n" + "    ".repeat(walk_step) );
        }

        let getter_last;
        if (descriptor_property !== "value") {
        getter_last = textref(`
        (global.set $${global_name}
            (call $wat2wasm/Reflect.get<refx2>${kindshort}
                (call $wat2wasm/Reflect.getOwnPropertyDescriptor<refx2>ref
                    ${path_walk}
                    (text "${last_object}") 
                )
                (text "${descriptor_property}") 
            )
        )
        `);
        } else {
        getter_last = textref(`
        (global.set $${global_name}
            (call $wat2wasm/Reflect.get<refx2>${kindshort}
                ${path_walk}
                (text "${last_object}") 
            )
        )
        `);
        }

        setters = setters.concat(getter_last);
        content = content.replaceFrame( match, `(global $${match[1]} ${kinddefiner} ${initial})` );
    }   
    
    return callOnStart(content, setters);
}

const globaltextref     = content => {

    let match;
    let setters = ``;
    
    while (match = content.matchFrame(/\(global\s+\$(.*)\s+\"(.*)\"\s?\)/)) {

        const stringer = textref( ` (text "${match[2]}") ` ).trim();
        const setter = textref(`(global.set $${match[1]} ${stringer})`);

        setters = setters.concat(setter);
        content = content.replaceFrame( match, `(global $${match[1]} (mut externref) ref.null extern)` );
    }   
    
    return callOnStart(content, setters);
}


const selffuncimport    = content => {

    let match;
    let importers = ``;
    
    content = content.replaceAll(/\(call\s+\$self\.([a-zA-Z0-9\.\_]+)\s+(i32|f32|i64|f64|ref|externref)\)/g, 
        `(call $self.$1<>$2)`
    ).replaceAll(">externref", ">ref");    

    
    while (match = content.matchFrame(/\(call\s+(\$self\.([a-zA-Z0-9._:/]+)<(.*?)>([a-z0-9]*))/)) {

        let [ root, sub, ...rest ] = match[2].trim().split(".");

        if (rest.length) {
            process.exit("maximum two level deeper allowed:", match.frame);
        }

        if (!sub) {
            sub = root;
            root = "self";
        }

        const params = String("(param ").concat(match[3].trim().split(".").flatMap(d => {
            const [kind, multiplier] = d.split("x");
            const array = new Array( Number(multiplier) || 1 );
            
            return array.fill(kind);
        })
        .map(k => k.replace('ref', 'externref'))
        .map(k => k.replace('fun', 'funcref'))
        .join(" ")).concat(")").replace("(param )", "");
        
        const results = String("(result ").concat(match[4].trim().split(".").flatMap(d => {
            const [kind, multiplier] = d.split("x");
            const array = new Array( Number(multiplier) || 1 );
            
            return array.fill(kind);
        })
        .map(k => k.replace('ref', 'externref'))
        .map(k => k.replace('fun', 'funcref'))
        .join(" ")).concat(")").replace("(result )", "");

        const definition = `(func ${match[1]} ${params} ${results}`.trim().concat(")");
        const importer = `\n\t(import "${root}" "${sub}" ${definition})`;

        content = content.replaceFrame( match, match.frame.replace("$self.", "$SELF.") );
        
        if (importers.indexOf(importer) === -1) {
            importers += importer;
        }
    }   

    content = content.substring( 0, content.indexOf(";;END_OF_IMPORTS")-1 ).concat(
        importers
    ).concat("\n\t").concat( 
        content.substring( content.indexOf(";;END_OF_IMPORTS")-1 )
    );

    return content.replaceAll("$SELF.", "$self.");
}

const applycalls        = content => {

    let match;
    let definers = ``;

    content = content.replaceAll(/\(apply\s+\$self\.([a-zA-Z0-9\.\_]+)\s?\)/g, 
        `(apply $self.$1<> (global.get $wat2wasm/self) (param))`
    );    
    
    content = content.replaceAll(/\(apply\s+\$self\.([a-zA-Z0-9\.\_]+)\s+(i32|f32|i64|f64|ref|externref)\)/g, 
        `(apply $self.$1<>$2 (global.get $wat2wasm/self) (param))`
    ).replaceAll(">externref", ">ref");    

    
    content = content.replaceAll(/\(apply\s+\$self\.([a-zA-Z0-9\.\_]+)<(.*?)>([a-z0-9]*)\s?\)/g, 
        `(apply $self.$1<$2>$3 (global.get $wat2wasm/self) (param))`
    );    
    
    while (match = content.matchFrame(/\(apply\s+(\$self\.([a-zA-Z0-9._:/]+)<(.*?)>([a-z0-9]*))/)) {

        const prm = match[3].trim();
        const params = String("(param ").concat(prm.split(".").flatMap(d => {
            const [kind, multiplier] = d.split("x");
            const array = new Array( Number(multiplier) || 1 );
            
            return array.fill(kind);
        })
        .map(k => k.replace('ref', 'externref'))
        .map(k => k.replace('fun', 'funcref'))
        .join(" ")).concat(")").replace("(param )", "");
        
        const res = match[4].trim();
        const results = String("(result ").concat(res.split(".").flatMap(d => {
            const [kind, multiplier] = d.split("x");
            const array = new Array( Number(multiplier) || 1 );
            
            return array.fill(kind);
        })
        .map(k => k.replace('ref', 'externref'))
        .map(k => k.replace('fun', 'funcref'))
        .join(" ")).concat(")").replace("(result )", "");

        let frame = match.frame.replace(
        `(apply ${match[1]}`, `(call $self.Reflect.apply<refx3>${res} 
            (global.get $self.${match[2]})`
        ).replace(
        `(param`, `(call $self.Array.of<${prm}>ref`
        );

        const definer = `\n\t(global $self.${match[2]} externref)`;
        
        if (content.indexOf(definer.trim()) === -1) {
            if (definers.indexOf(definer.trim()) === -1) {
                definers += definer;
            }
        }
        
        content = content.replaceFrame( match, frame );
    }   

    content = content.substring( 0, content.lastIndexOf(")") ).concat(
        definers
    ).concat("\n)");

    return content;
}

const consts            = content => {
    return content
        .replaceAll(/(i32|i64|f32|f64)\(([0-9.]+)\)/g, `($1.const $2)`)
        .replaceAll(/(local|global|table)\(/g, `($1.get `)
        .replaceAll(/\((self|null|this)\)/g, ` ($1) `)
        .replaceAll(/(\s)this(\s)/g, `$1(local.get 0)$2`)
        .replaceAll(/(\s)self(\s)/g, `$1(global.get $wat2wasm/self)$2`)
        .replaceAll(/(\s)null(\s)/g, `$1(ref.null extern)$2`)
    ;
};

const constructcalls    = content => {

    let match;
    let definers = ``;

    content = content
        .replaceAll(`(new $`, `(construct $self.`)
        .replaceAll('(construct $self.self.', '(construct $self.')
    ;    
    
    content = content.replaceAll(/\(construct\s+\$self\.([a-zA-Z0-9\.\_]+)\s?\)/g, 
        `(construct $self.$1<>ref (param))`
    );    
    
    content = content.replaceAll(/\(construct\s+\$self\.([a-zA-Z0-9\.\_]+)\s+(i32|f32|i64|f64|ref|externref)\)/g, 
        `(construct $self.$1<>$2 (param))`
    ).replaceAll(">externref", ">ref");    

    
    content = content.replaceAll(/\(construct\s+\$self\.([a-zA-Z0-9\.\_]+)<(.*?)>([a-z0-9]*)\s?\)/g, 
        `(construct $self.$1<$2>$3 (param))`
    );    
    
    while (match = content.matchFrame(/\(construct\s+(\$self\.([a-zA-Z0-9._:/]+)<(.*?)>([a-z0-9]*))/)) {

        let frame;
    
    if (match.frame.indexOf("(param") !== -1) {
        frame = match.frame.replace(
        `(construct ${match[1]}`, `(call $self.Reflect.construct<refx2>ref 
            (global.get $self.${match[2]}) `
        ).replace(
        `(param`, `(call $self.Array.of<${match[3].trim()}>ref`
        );
    } else {
        frame = match.frame.replace(
        `(construct ${match[1]}`, 
        `(call $self.Reflect.construct<refx2>ref 
            (global.get $self.${match[2]}) 
            (call $self.Array.of<${match[3].trim()}>ref `
        ).concat( `)` );
    }

        const definer = `\n\t(global $self.${match[2]} externref)`;
        
        if (content.indexOf(definer.trim()) === -1) {
            if (definers.indexOf(definer.trim()) === -1) {
                definers += definer;
            }
        }
        
        content = content.replaceFrame( match, frame );
    }   

    content = content.substring( 0, content.lastIndexOf(")") ).concat(
        definers
    ).concat("\n)");

    return content;
}

const elemrefs          = content => {

    let match;
    let refs = [];
    while (match = content.matchFrame(/\(ref.func\s+\$(.[^\s\)]+)\)/)) {
        content = content.replaceFrame( match, match.frame.replace("$", "###") );
        refs.push(match.frame);
    }   

    content = content.substring( 0, content.lastIndexOf(")") ).concat(
        `\n\t(elem $wat2wasm/refs funcref ${refs.join(" ")})`
    ).concat("\n").concat( 
        content.substring( content.lastIndexOf(")") )
    );

    return content.replaceAll("###", "$");
}


const compile   = () => {
    const rawFileContentBuffer = readFileSync(inputFilePath);
    const rawFileContentString = rawFileContentBuffer.toString();

    let 
    content = rawFileContentString
                .replaceAll("(self)", "(global.get $wat2wasm/self)")
                .replaceAll("(null)", "(ref.null extern)")
            ;
    content = addImports(content);
    content = include(content);
    content = consoles(content);
    content = start(content);
    content = consts(content);
    content = constructcalls(content);
    content = applycalls(content);
    content = inlinefuncs(content);
    content = textref(content);
    content = selfref(content);
    content = elemrefs(content);
    content = globaltextref(content);
    content = selffuncimport(content);

    if (tbl_extern.length > 1) {
        content = appendExternTable(content);
    }

    if (data_text_offset > 0) {
        content = appendTextData(content);
    }

    console.log(" ");
    console.log(Date.now());
    // console.log(content);

    writeFileSync( modifiedContentInputFilePath, content );

    execSync(
        `wat2wasm 
            ${modifiedContentInputFilePath} 
            ${enableThreadsCompileOptions}  
            ${multiMemoryCompileOptions} 
            ${debugNamesCompileOptions} 
            -o ${outputFilePath}    
        `.replaceAll(/\s+/g, " ")
    ) && noUnlinkCompileOptions || unlinkSync( modifiedContentInputFilePath );
};

if (compileOptions.includes("--watch")) {
    watchFile( inputFilePath, compile );
}

compile();

